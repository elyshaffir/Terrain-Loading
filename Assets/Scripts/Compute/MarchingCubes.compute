#pragma kernel MarchCubes
#include "Imported/MarchTables.compute"
#include "Utils/DataStructures/Point.compute"
#include "Utils/ChunkIndexing.compute"

StructuredBuffer<Point> points;
StructuredBuffer<uint3> cubesToMarch;

///
RWStructuredBuffer<uint> currentCube; // acts as some sort of semaphore
AppendStructuredBuffer<float3> meshVertices;
AppendStructuredBuffer<int> meshTriangles;
///

uint numPointsX;
uint numPointsY;

float isoLevel;

float3 InterpolateVerts(Point v1, Point v2)
{
	float t = (isoLevel - v1.surfaceLevel) / (v2.surfaceLevel - v1.surfaceLevel);
	return v1.position + t * (v2.position - v1.position);
}

int GetCubeIndex(Point cubeCorners[8])
{
	int cubeIndex = 0;
	if (cubeCorners[0].surfaceLevel < isoLevel)
		cubeIndex |= 1;
	if (cubeCorners[1].surfaceLevel < isoLevel)
		cubeIndex |= 2;
	if (cubeCorners[2].surfaceLevel < isoLevel)
		cubeIndex |= 4;
	if (cubeCorners[3].surfaceLevel < isoLevel)
		cubeIndex |= 8;
	if (cubeCorners[4].surfaceLevel < isoLevel)
		cubeIndex |= 16;
	if (cubeCorners[5].surfaceLevel < isoLevel)
		cubeIndex |= 32;
	if (cubeCorners[6].surfaceLevel < isoLevel)
		cubeIndex |= 64;
	if (cubeCorners[7].surfaceLevel < isoLevel)
		cubeIndex |= 128;
	return cubeIndex;
}

void AddTriangle(uint cubeToMarchIndex, float3 vertexA, float3 vertexB, float3 vertexC)
{
	// meshVertices.Append(float3(69, 420, 1));	// doesn't work, retrieving data is broken
	// length of meshVertices is proper and deterministic as shown from CPU logs
	uint loopCounter = 0; // this is here to make sure that the compiler doesn't get rid of this loop
	// while (currentCube[0] != cubeToMarchIndex && loopCounter < 2000)
	// {
	// 	loopCounter++;
	// }
	currentCube[1] = loopCounter; // just to use the variable to avoid compiler bulshit
	meshVertices.Append(vertexC);	
	meshVertices.Append(vertexB);
	meshVertices.Append(vertexA);
	meshTriangles.Append(cubeToMarchIndex * 3);
	meshTriangles.Append(cubeToMarchIndex * 3 + 1);
	meshTriangles.Append(cubeToMarchIndex * 3 + 2);
	currentCube[0] = cubeToMarchIndex + 1;
	// currentCube[0] = vertexC.x; // the vertices are calculated correctly
}

[numthreads(5, 1, 1)]
void MarchCubes(uint3 id : SV_DispatchThreadID)
{
	uint cubeToMarchIndex = IndexFromCoords(id.x, numPointsX, id.y, numPointsY, id.z);
	if (cubeToMarchIndex < (uint)cubesToMarch.Length)
	{
		uint3 cubeToMarch = cubesToMarch[cubeToMarchIndex];
		Point cubeCorners[8] = {
			points[IndexFromCoords(cubeToMarch.x, numPointsX, cubeToMarch.y, numPointsY, cubeToMarch.z)],
			points[IndexFromCoords(cubeToMarch.x + 1, numPointsX, cubeToMarch.y, numPointsY, cubeToMarch.z)],
			points[IndexFromCoords(cubeToMarch.x + 1, numPointsX, cubeToMarch.y, numPointsY, cubeToMarch.z + 1)],
			points[IndexFromCoords(cubeToMarch.x, numPointsX, cubeToMarch.y, numPointsY, cubeToMarch.z + 1)],
			points[IndexFromCoords(cubeToMarch.x, numPointsX, cubeToMarch.y + 1, numPointsY, cubeToMarch.z)],
			points[IndexFromCoords(cubeToMarch.x + 1, numPointsX, cubeToMarch.y + 1, numPointsY, cubeToMarch.z)],
			points[IndexFromCoords(cubeToMarch.x + 1, numPointsX, cubeToMarch.y + 1, numPointsY, cubeToMarch.z + 1)],
			points[IndexFromCoords(cubeToMarch.x, numPointsX, cubeToMarch.y + 1, numPointsY, cubeToMarch.z + 1)]};

		int cubeIndex = GetCubeIndex(cubeCorners);
		/*
			Instead of an AppendBuffer, have a StructuredBuffer of triangles, and
			index triangles there by cubeToMarchIndex (with maximum spacing between triangles).
			Then, via another ComputeShader make that StructuredBuffer into the vertices and
			triangles of the mesh.
			Then, it might be possible to optimize the recalculation of cubes while manipulating
			only to the relevant cubes.
			max num of tris in cube: 5
		*/
		for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3)
		{
			int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
			int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

			int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 1]];
			int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 1]];

			int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 2]];
			int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 2]];
			
			float3 vertexA = InterpolateVerts(cubeCorners[a0], cubeCorners[b0]);
			float3 vertexB = InterpolateVerts(cubeCorners[a1], cubeCorners[b1]);
			float3 vertexC = InterpolateVerts(cubeCorners[a2], cubeCorners[b2]);

			AddTriangle(cubeToMarchIndex, vertexA, vertexB, vertexC);			
		}		
	}	
}