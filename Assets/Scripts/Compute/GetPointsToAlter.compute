#pragma kernel GetPointsToAlter
#include "Utils/DataStructures/Point.compute"
#include "Utils/ChunkIndexing.compute"

static const int numThreadsGetPointsToAlter = 5;
RWStructuredBuffer<uint> relevantCubeCorners;
RWStructuredBuffer<Point> points;
RWStructuredBuffer<int> onEdges;
/*
an array of 6 ints, the indices are:
0: -x
1: -y
2: -z
3: z
4: y
5: x
*/

int numPointsX;
int numPointsY;
int numPointsZ;

float power;
float3 chunkPosition;
float sphereRadius;
float3 spherePosition;

void AddCube(uint3 cube)
{
    uint index = indexFromCoordsInCubes(cube.x, numPointsX, cube.y, numPointsY, cube.z);
    relevantCubeCorners[index] = 1;
}

void AddRelevantCubes(uint3 id)
{
    AddCube(id);
    if (id.x > 0)
    {
        AddCube(uint3(id.x - 1, id.y, id.z));
        if (id.y > 0)
        {
            AddCube(uint3(id.x - 1, id.y - 1, id.z));
            if (id.z > 0)
            {
                AddCube(uint3(id.x - 1, id.y - 1, id.z - 1));
            }
        }
        if (id.z > 0)
        {
            AddCube(uint3(id.x - 1, id.y, id.z - 1));
        }
    }
    if (id.y > 0)
    {
        AddCube(uint3(id.x, id.y - 1, id.z));
        if (id.z > 0)
        {
            AddCube(uint3(id.x, id.y - 1, id.z - 1));
        }
    }
    if (id.z > 0)
    {
        AddCube(uint3(id.x, id.y, id.z - 1));
    }
}

void CalculateEdges(uint3 id) {    
    if (id.x == 0)
    {
        onEdges[0] = 1;
    }
    else if (id.x + 1 == numPointsX)
    {
        onEdges[5] = 1;
    }
    if (id.y == 0)
    {
        onEdges[1] = 1;
    }
    else if (id.y + 1 == numPointsY)
    {
        onEdges[4] = 1;
    }
    if (id.z == 0)
    {
        onEdges[2] = 1;
    }
    else if (id.z + 1 == numPointsZ)
    {
        onEdges[3] = 1;
    }    
}

[numthreads(numThreadsGetPointsToAlter, numThreadsGetPointsToAlter, numThreadsGetPointsToAlter)]
void GetPointsToAlter(uint3 id : SV_DispatchThreadID)
{
    int index = indexFromCoords(id.x, numPointsX, id.y, numPointsY, id.z);    
    if (distance(spherePosition, points[index].position + chunkPosition) <= sphereRadius)
    {
        points[index].surfaceLevel += power;
        AddRelevantCubes(id);
        CalculateEdges(id);
    }    
}